---
phase: 03-quality-intelligence-sdks
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - hivemind/api/__init__.py
  - hivemind/api/router.py
  - hivemind/api/auth.py
  - hivemind/api/middleware.py
  - hivemind/api/routes/__init__.py
  - hivemind/api/routes/knowledge.py
  - hivemind/api/routes/outcomes.py
  - hivemind/server/main.py
autonomous: true
requirements:
  - SDK-01

must_haves:
  truths:
    - "A developer can call GET /api/v1/knowledge/search with an X-API-Key header and receive search results"
    - "A developer can call GET /api/v1/knowledge/{id} to fetch full item content"
    - "API key authentication validates the hashed key against the api_keys table"
    - "Each API request increments the request_count on the ApiKey record for usage metering"
    - "Invalid or missing API keys return 401"
  artifacts:
    - path: "hivemind/api/router.py"
      provides: "FastAPI APIRouter with /api/v1/ prefix"
      exports: ["api_router"]
    - path: "hivemind/api/auth.py"
      provides: "API key authentication dependency"
      exports: ["require_api_key"]
    - path: "hivemind/api/middleware.py"
      provides: "Usage metering middleware"
      exports: ["UsageMeteringMiddleware"]
    - path: "hivemind/api/routes/knowledge.py"
      provides: "Knowledge search and fetch endpoints"
      contains: "search_knowledge"
    - path: "hivemind/api/routes/outcomes.py"
      provides: "Outcome reporting endpoint"
      contains: "report_outcome"
  key_links:
    - from: "hivemind/api/auth.py"
      to: "hivemind/db/models.py"
      via: "validates API key against ApiKey model"
      pattern: "ApiKey"
    - from: "hivemind/api/middleware.py"
      to: "hivemind/db/models.py"
      via: "increments request_count on ApiKey"
      pattern: "request_count"
    - from: "hivemind/server/main.py"
      to: "hivemind/api/router.py"
      via: "app.include_router(api_router)"
      pattern: "include_router"
---

<objective>
Create the REST API layer that enables developer access to HiveMind without MCP.

Purpose: Developers building integrations need standard HTTP endpoints with API key authentication. This layer wraps the same knowledge operations available via MCP tools into REST endpoints that generated SDKs (Plan 07) will target. The REST API also enables usage metering per billing period for the existing ApiKey model.

Output: FastAPI router at /api/v1/ with knowledge search, fetch, and outcome reporting endpoints, API key auth dependency, and usage metering middleware — all mounted on the existing FastAPI app.
</objective>

<execution_context>
@/Users/amirkellousidhoum/.claude/get-shit-done/workflows/execute-plan.md
@/Users/amirkellousidhoum/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-quality-intelligence-sdks/03-RESEARCH.md

# Existing API key model and auth patterns
@hivemind/db/models.py
@hivemind/security/api_key.py
@hivemind/server/main.py
@hivemind/server/auth.py
@hivemind/server/tools/search_knowledge.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: REST API router with API key auth and metering middleware</name>
  <files>
    hivemind/api/__init__.py
    hivemind/api/router.py
    hivemind/api/auth.py
    hivemind/api/middleware.py
    hivemind/api/routes/__init__.py
  </files>
  <action>
    1. Create `hivemind/api/__init__.py` — empty init file.
    2. Create `hivemind/api/routes/__init__.py` — empty init file.

    3. Create `hivemind/api/auth.py` with `require_api_key` dependency:
       - Use `APIKeyHeader(name="X-API-Key", auto_error=True)` from `fastapi.security`.
       - `async def require_api_key(api_key: str = Security(API_KEY_HEADER), session: AsyncSession = Depends(get_async_session)) -> ApiKey`:
         - Hash the key with SHA-256 (same pattern as existing `validate_api_key` in security/api_key.py)
         - Query `api_keys` table for matching active key
         - If not found or not active: raise HTTPException(401, "Invalid or inactive API key")
         - Check billing period: if `billing_period_start + billing_period_reset_days` < now, reset `request_count = 0` and update `billing_period_start = now`
         - Return the ApiKey record
       - Use a dependency for AsyncSession: `async def get_async_session()` that yields from `get_session()`.
       - Import hashlib for SHA-256.

    4. Create `hivemind/api/middleware.py` with `UsageMeteringMiddleware`:
       - This is a FastAPI dependency (not Starlette middleware) that runs after the request handler.
       - Implement as an async dependency that increments `request_count` on the ApiKey after the route handler returns.
       - Alternative simpler approach: make metering part of the `require_api_key` dependency itself — increment `request_count` and `last_used_at` in the same DB transaction as key validation. This is simpler and avoids a separate middleware class.
       - Use `session.execute(update(ApiKey).where(ApiKey.id == key.id).values(request_count=ApiKey.request_count + 1, last_used_at=datetime.datetime.now(datetime.timezone.utc)))` for atomic increment.

    5. Create `hivemind/api/router.py`:
       - `api_router = APIRouter(prefix="/api/v1", tags=["rest-api"])`.
       - Import and include sub-routers from routes/ (knowledge, outcomes).
       - This is the top-level router that server/main.py will mount.

    AVOID: Do NOT create a Starlette BaseHTTPMiddleware — use FastAPI dependency injection for metering (cleaner, testable, no raw request/response manipulation).
  </action>
  <verify>
    Run `cd /Users/amirkellousidhoum/Desktop/Code/HiveMind && python -c "
from hivemind.api.router import api_router
from hivemind.api.auth import require_api_key
print(f'Router prefix: {api_router.prefix}')
print('Auth dep exists:', callable(require_api_key))
print('OK')
"` — should print the prefix and True.
  </verify>
  <done>
    API router exists at /api/v1/ prefix. require_api_key dependency validates API keys against the existing api_keys table with SHA-256 hash lookup. Metering atomically increments request_count and updates last_used_at on each authenticated request.
  </done>
</task>

<task type="auto">
  <name>Task 2: Knowledge and outcomes REST endpoints + mount on FastAPI app</name>
  <files>
    hivemind/api/routes/knowledge.py
    hivemind/api/routes/outcomes.py
    hivemind/server/main.py
  </files>
  <action>
    1. Create `hivemind/api/routes/knowledge.py` with two endpoints:
       - `GET /knowledge/search` — query params: `query` (str, required), `category` (str, optional), `limit` (int, default=10, max=50), `cursor` (str, optional)
         - Depends on `require_api_key` for auth
         - Reuses the embedding + cosine search logic from search_knowledge.py `_search()` but wrapped for REST
         - Extract `org_id` from the authenticated ApiKey record
         - Return JSON: `{ results: [...], total_found: int, next_cursor: str | null }`
         - Each result: `{ id, title, category, confidence, org_attribution, relevance_score }`
       - `GET /knowledge/{item_id}` — path param: item_id (UUID)
         - Depends on `require_api_key` for auth
         - Reuses `_fetch_by_id()` logic from search_knowledge.py
         - Return full item JSON with integrity verification
       - Both endpoints should call shared internal functions to avoid duplicating query logic. Import `_search` and `_fetch_by_id` from `hivemind.server.tools.search_knowledge` — these accept org_id as parameter and are not MCP-specific.
       - Add custom operation_id names for clean SDK generation: `operation_id="search_knowledge"` and `operation_id="get_knowledge_item"`.

    2. Create `hivemind/api/routes/outcomes.py` with one endpoint:
       - `POST /outcomes` — body: `{ item_id: str (UUID), outcome: "solved" | "did_not_help", run_id: str | None }`
         - Depends on `require_api_key` for auth
         - This is a placeholder that will be fully wired in Plan 03 (when quality signal recording exists)
         - For now: validate input, return `{ status: "recorded", item_id: ..., outcome: ... }`
         - Use Pydantic BaseModel for request body validation
       - Add `operation_id="report_outcome"`.

    3. Update `hivemind/server/main.py`:
       - Import `api_router` from `hivemind.api.router`
       - Add `app.include_router(api_router)` AFTER the health endpoint definition and BEFORE the MCP mount
       - Add a custom `generate_unique_id` function for clean SDK method names (per research Pattern 6):
         ```python
         def custom_generate_unique_id(route: APIRoute) -> str:
             if route.tags:
                 return f"{route.tags[0]}-{route.name}"
             return route.name
         ```
         Pass to FastAPI constructor: `generate_unique_id_function=custom_generate_unique_id`
       - Import `APIRoute` from `fastapi.routing`

    AVOID: Do NOT duplicate the search query building from search_knowledge.py — import and reuse the internal _search and _fetch_by_id functions. The REST layer is a thin HTTP adapter over the same logic.
  </action>
  <verify>
    Run `cd /Users/amirkellousidhoum/Desktop/Code/HiveMind && python -c "
from hivemind.server.main import app
routes = [r.path for r in app.routes]
print('Has /api/v1 routes:', any('/api/v1' in r for r in routes))
print('Has /health:', '/health' in routes)
print('Routes:', [r for r in routes if '/api' in r])
"` — should show /api/v1/knowledge/search, /api/v1/knowledge/{item_id}, /api/v1/outcomes.
  </verify>
  <done>
    REST API endpoints for knowledge search, fetch, and outcome reporting are live at /api/v1/. All endpoints require X-API-Key header. The search endpoint returns the same result shape as the MCP search_knowledge tool. FastAPI app generates clean operation IDs for SDK generation. The /openapi.json spec includes all REST endpoints.
  </done>
</task>

</tasks>

<verification>
1. `python -c "from hivemind.api.router import api_router"` succeeds
2. `python -c "from hivemind.server.main import app"` succeeds (no import errors from new router)
3. The OpenAPI spec at `/openapi.json` includes /api/v1/ endpoints
4. require_api_key validates against the existing api_keys table
5. Usage metering increments request_count atomically
</verification>

<success_criteria>
- GET /api/v1/knowledge/search returns search results with API key auth
- GET /api/v1/knowledge/{item_id} returns full item with integrity check
- POST /api/v1/outcomes accepts outcome reports
- Invalid API keys return 401
- Each request increments the ApiKey's request_count
- OpenAPI spec has clean operation IDs for SDK generation
</success_criteria>

<output>
After completion, create `.planning/phases/03-quality-intelligence-sdks/03-02-SUMMARY.md`
</output>
