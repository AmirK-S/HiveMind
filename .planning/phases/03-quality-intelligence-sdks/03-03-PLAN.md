---
phase: 03-quality-intelligence-sdks
plan: 03
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - hivemind/server/tools/report_outcome.py
  - hivemind/server/main.py
  - hivemind/temporal/__init__.py
  - hivemind/temporal/queries.py
  - hivemind/server/tools/search_knowledge.py
  - hivemind/api/routes/outcomes.py
autonomous: true
requirements:
  - MCP-06
  - KM-06

must_haves:
  truths:
    - "An agent can call report_outcome MCP tool with item_id and 'solved'/'did_not_help' and the signal is recorded"
    - "Reporting an outcome increments helpful_count or not_helpful_count on the knowledge item"
    - "Temporal query 'what was known at time T' returns only items valid at that time"
    - "Version-scoped temporal query filters by version column"
    - "search_knowledge supports an optional at_time parameter for point-in-time queries"
  artifacts:
    - path: "hivemind/server/tools/report_outcome.py"
      provides: "MCP tool for outcome reporting"
      exports: ["report_outcome"]
    - path: "hivemind/temporal/queries.py"
      provides: "Bi-temporal query helpers"
      exports: ["build_temporal_filter", "query_at_time"]
    - path: "hivemind/server/tools/search_knowledge.py"
      provides: "Updated search with temporal filter support"
      contains: "at_time"
  key_links:
    - from: "hivemind/server/tools/report_outcome.py"
      to: "hivemind/quality/signals.py"
      via: "calls record_signal() + increment helpers"
      pattern: "record_signal"
    - from: "hivemind/temporal/queries.py"
      to: "hivemind/db/models.py"
      via: "filters on valid_at/invalid_at/expired_at columns"
      pattern: "valid_at"
    - from: "hivemind/server/tools/search_knowledge.py"
      to: "hivemind/temporal/queries.py"
      via: "applies temporal filter to search query"
      pattern: "build_temporal_filter"
---

<objective>
Wire outcome reporting (MCP + REST) and temporal query support into the system.

Purpose: MCP-06 requires agents to report whether retrieved knowledge actually helped. These signals are the primary driver of quality score evolution (QI-01/QI-02). Temporal queries (KM-06) enable point-in-time knowledge retrieval, which is essential for version-scoped knowledge and historical accuracy.

Output: report_outcome MCP tool, wired REST outcome endpoint, temporal query helpers, and temporal filter integration in search_knowledge.
</objective>

<execution_context>
@/Users/amirkellousidhoum/.claude/get-shit-done/workflows/execute-plan.md
@/Users/amirkellousidhoum/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-quality-intelligence-sdks/03-RESEARCH.md

# Plan 01 creates quality signal infrastructure
@.planning/phases/03-quality-intelligence-sdks/03-01-SUMMARY.md

@hivemind/server/tools/search_knowledge.py
@hivemind/server/main.py
@hivemind/server/auth.py
@hivemind/quality/signals.py
@hivemind/db/models.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: report_outcome MCP tool and REST endpoint wiring</name>
  <files>
    hivemind/server/tools/report_outcome.py
    hivemind/server/main.py
    hivemind/api/routes/outcomes.py
  </files>
  <action>
    1. Create `hivemind/server/tools/report_outcome.py`:
       - `async def report_outcome(item_id: str, outcome: str, run_id: str | None = None) -> dict | CallToolResult`:
         - Auth: extract JWT from headers using the same `_extract_auth()` pattern as other tools (get_http_headers -> parse Bearer -> decode_token)
         - Validate `outcome` is one of "solved" or "did_not_help" — return isError if not
         - Validate `item_id` is a valid UUID — return isError if not
         - Verify the item exists and is accessible to this org (same org isolation as search)
         - Determine signal_type: "outcome_solved" if outcome == "solved", else "outcome_not_helpful"
         - Call `record_signal(knowledge_item_id=item_id, signal_type=signal_type, agent_id=auth.agent_id, run_id=run_id)`
         - Update denormalized counters: if "solved", atomically increment `helpful_count` on KnowledgeItem; if "did_not_help", increment `not_helpful_count`
         - Use `async with get_session() as session` for the update: `UPDATE knowledge_items SET helpful_count = helpful_count + 1 WHERE id = :id`
         - Return `{ status: "recorded", item_id: ..., outcome: ..., signal_id: ... }`
       - Docstring should clearly state this is MCP-06: explicit active confirmation signal for quality scoring.

    2. Register the tool in `hivemind/server/main.py`:
       - Import `report_outcome` from `hivemind.server.tools.report_outcome`
       - Add `mcp.add_tool(Tool.from_function(report_outcome))` after the existing tool registrations
       - Update the comment: "Seven total MCP tools registered" (was six)

    3. Update `hivemind/api/routes/outcomes.py` (created as stub in Plan 02):
       - Replace the placeholder with actual signal recording logic
       - Import `record_signal` from `hivemind.quality.signals`
       - Extract `org_id` from the authenticated ApiKey (from require_api_key dependency)
       - Validate item exists and belongs to this org
       - Record the signal and update denormalized counters (same logic as MCP tool)
       - Return the recorded signal info

    AVOID: Do NOT allow duplicate outcome reports for the same (item_id, agent_id, run_id) combination. Check for existing signal with matching run_id before inserting. If duplicate detected, return success with a "already_recorded" status (idempotent).
  </action>
  <verify>
    Run `cd /Users/amirkellousidhoum/Desktop/Code/HiveMind && python -c "
from hivemind.server.tools.report_outcome import report_outcome
from hivemind.server.main import mcp
tool_names = [t.name for t in mcp._tool_manager._tools.values()]
print('report_outcome in tools:', 'report_outcome' in tool_names)
print('Total tools:', len(tool_names))
"` — should show report_outcome registered, 7 total tools.
  </verify>
  <done>
    report_outcome MCP tool records "solved"/"did_not_help" signals with deduplication by run_id. REST endpoint at POST /api/v1/outcomes is wired to the same signal recording logic. Denormalized helpful_count/not_helpful_count counters are atomically updated on each outcome report.
  </done>
</task>

<task type="auto">
  <name>Task 2: Bi-temporal query helpers and search_knowledge temporal filter</name>
  <files>
    hivemind/temporal/__init__.py
    hivemind/temporal/queries.py
    hivemind/server/tools/search_knowledge.py
  </files>
  <action>
    1. Create `hivemind/temporal/__init__.py` — empty init file.

    2. Create `hivemind/temporal/queries.py` with:
       - `def build_temporal_filter(at_time: datetime.datetime) -> list`:
         Returns a list of SQLAlchemy WHERE clause conditions for point-in-time filtering:
         ```python
         [
           KnowledgeItem.valid_at <= at_time,
           or_(KnowledgeItem.invalid_at.is_(None), KnowledgeItem.invalid_at > at_time),
           KnowledgeItem.expired_at.is_(None),  # only current system-time rows
         ]
         ```
         These conditions can be unpacked into any select() statement via `stmt.where(*conditions)`.

       - `async def query_at_time(query_embedding: list[float], org_id: str, at_time: datetime.datetime, version: str | None = None, category: str | None = None, limit: int = 10) -> list[dict]`:
         Full point-in-time query that:
         - Builds a SELECT on KnowledgeItem with cosine distance ranking
         - Applies temporal filter via build_temporal_filter()
         - Applies org isolation (org_id match OR is_public)
         - Applies optional version filter on KnowledgeItem.version column
         - Applies optional category filter
         - Returns results as list of dicts with id, content, category, relevance_score, valid_at, version

       Import `or_` from sqlalchemy. Import KnowledgeItem from models.

    3. Update `hivemind/server/tools/search_knowledge.py`:
       - Add optional `at_time: str | None = None` parameter to the `search_knowledge()` function signature.
         The parameter accepts an ISO 8601 datetime string. If provided, the search returns only items that were valid at that time.
       - In `_search()` function, add `at_time: str | None = None` parameter.
       - If at_time is provided:
         - Parse the ISO 8601 string to datetime: `target_time = datetime.datetime.fromisoformat(at_time)`
         - Import `build_temporal_filter` from `hivemind.temporal.queries`
         - Apply temporal conditions: `for condition in build_temporal_filter(target_time): stmt = stmt.where(condition)`
       - If at_time is None: no temporal filter applied (current behavior — backward compatible).
       - Also add optional `version: str | None = None` parameter. If provided with at_time, filter by `KnowledgeItem.version == version`.
       - Pass both new params through from the top-level function to `_search()`.
       - Update the docstring to document the new temporal query parameters.

    AVOID: Do NOT break existing search behavior — at_time=None must produce identical results to current behavior. The temporal filter is additive.
    AVOID: Do NOT filter items where valid_at IS NULL when at_time is provided — items with NULL valid_at are "always valid" (pre-temporal-migration items). Treat NULL valid_at as valid_at = -infinity (always passes the <= check). Update build_temporal_filter: `or_(KnowledgeItem.valid_at.is_(None), KnowledgeItem.valid_at <= at_time)`.
  </action>
  <verify>
    Run `cd /Users/amirkellousidhoum/Desktop/Code/HiveMind && python -c "
import datetime
from hivemind.temporal.queries import build_temporal_filter
conditions = build_temporal_filter(datetime.datetime.now(datetime.timezone.utc))
print(f'Temporal conditions: {len(conditions)} clauses')
print('OK')
"` — should print 3 clauses.
    Run `python -c "import inspect; from hivemind.server.tools.search_knowledge import search_knowledge; sig = inspect.signature(search_knowledge); print('at_time' in sig.parameters)"` — should print True.
  </verify>
  <done>
    build_temporal_filter() returns SQLAlchemy conditions for point-in-time queries. query_at_time() provides a standalone temporal search. search_knowledge MCP tool accepts optional at_time and version parameters for temporal queries. Existing search behavior is unchanged when at_time is None. NULL valid_at items are treated as always-valid (backward compatible with pre-migration data).
  </done>
</task>

</tasks>

<verification>
1. report_outcome MCP tool is registered and callable
2. REST POST /api/v1/outcomes records signals
3. Outcome deduplication by run_id works
4. Temporal filter correctly selects items valid at a given time
5. search_knowledge with at_time returns only temporally-valid items
6. search_knowledge without at_time returns same results as before
</verification>

<success_criteria>
- An agent calling report_outcome("item-uuid", "solved") creates a quality signal and increments helpful_count
- search_knowledge(query="...", at_time="2026-01-01T00:00:00Z") returns only items with valid_at <= T and (invalid_at IS NULL or invalid_at > T)
- Version-scoped query (at_time + version) narrows results further
- Duplicate outcome reports (same item_id + run_id) are idempotent
</success_criteria>

<output>
After completion, create `.planning/phases/03-quality-intelligence-sdks/03-03-SUMMARY.md`
</output>
