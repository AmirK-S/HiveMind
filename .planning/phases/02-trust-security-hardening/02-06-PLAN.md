---
phase: 02-trust-security-hardening
plan: 06
type: execute
wave: 2
depends_on: [02-02, 02-03, 02-04]
files_modified:
  - hivemind/server/main.py
  - hivemind/server/tools/publish_knowledge.py
  - hivemind/server/tools/admin_tools.py
  - hivemind/cli/client.py
autonomous: true
requirements: [ACL-02, ACL-03, ACL-04, SEC-03, INFRA-03, INFRA-04]

must_haves:
  truths:
    - "Server lifespan initializes injection scanner, rate limiter, and Casbin enforcer alongside existing PII/embedder warmup"
    - "publish_knowledge MCP tool toggles is_public on a knowledge item (reversible publication to commons)"
    - "manage_roles MCP tool allows org admins to add/remove roles and policies"
    - "API key authentication works alongside existing JWT auth"
    - "approve_contribution triggers webhook dispatch after approval"
  artifacts:
    - path: "hivemind/server/main.py"
      provides: "Extended lifespan with injection scanner, rate limiter, RBAC enforcer init"
      contains: "InjectionScanner"
    - path: "hivemind/server/tools/publish_knowledge.py"
      provides: "publish_knowledge MCP tool for toggling is_public"
      exports: ["publish_knowledge"]
    - path: "hivemind/server/tools/admin_tools.py"
      provides: "manage_roles MCP tool for RBAC management"
      exports: ["manage_roles"]
    - path: "hivemind/cli/client.py"
      provides: "Webhook dispatch call in approve_contribution"
      contains: "dispatch_webhooks"
  key_links:
    - from: "hivemind/server/main.py"
      to: "hivemind/pipeline/injection.py"
      via: "InjectionScanner.get_instance() in lifespan"
      pattern: "InjectionScanner.get_instance"
    - from: "hivemind/server/tools/publish_knowledge.py"
      to: "hivemind/db/models.py"
      via: "KnowledgeItem.is_public toggle"
      pattern: "is_public"
    - from: "hivemind/server/tools/admin_tools.py"
      to: "hivemind/security/rbac.py"
      via: "add_policy, add_role_for_user"
      pattern: "from hivemind.security.rbac import"
    - from: "hivemind/cli/client.py"
      to: "hivemind/webhooks/tasks.py"
      via: "dispatch_webhooks() after approval"
      pattern: "dispatch_webhooks"
---

<objective>
Wire API key authentication, rate limiting, RBAC enforcement, webhook dispatch, and new MCP tools (publish_knowledge, manage_roles) into the server and CLI.

Purpose: This plan connects the security infrastructure (Plan 03), webhook delivery (Plan 04), and DB models (Plan 02) into the live request flow — completing the Phase 2 feature set.
Output: Updated server main.py with extended lifespan, two new MCP tools, and webhook dispatch in the CLI approval flow.
</objective>

<execution_context>
@/Users/amirkellousidhoum/.claude/get-shit-done/workflows/execute-plan.md
@/Users/amirkellousidhoum/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-trust-security-hardening/02-RESEARCH.md
@.planning/phases/02-trust-security-hardening/02-02-SUMMARY.md
@.planning/phases/02-trust-security-hardening/02-03-SUMMARY.md
@.planning/phases/02-trust-security-hardening/02-04-SUMMARY.md
@hivemind/server/main.py
@hivemind/server/tools/add_knowledge.py
@hivemind/cli/client.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend server lifespan and create publish_knowledge tool</name>
  <files>hivemind/server/main.py, hivemind/server/tools/publish_knowledge.py</files>
  <action>
**Update `hivemind/server/main.py` lifespan:**

Add imports at top:
```python
from hivemind.pipeline.injection import InjectionScanner
from hivemind.security.rbac import init_enforcer
from hivemind.security.rate_limit import init_rate_limiter
from hivemind.webhooks.tasks import configure_celery
from hivemind.config import settings
```

Extend the `lifespan()` function to initialize new Phase 2 components AFTER existing Phase 1 warmup:

After step 2 (embedding provider) and before step 3 (deployment config), add:

```python
# 2.5: Injection scanner — pre-load DeBERTa model (SEC-01)
logger.info("Loading injection scanner (DeBERTa model)...")
InjectionScanner.get_instance()
logger.info("Injection scanner ready.")

# 2.6: Rate limiter — connect to Redis (SEC-03, INFRA-04)
logger.info("Initializing rate limiter...")
await init_rate_limiter(settings.redis_url)
logger.info("Rate limiter ready.")

# 2.7: RBAC enforcer — load Casbin policies from PostgreSQL (ACL-03)
logger.info("Loading RBAC enforcer...")
await init_enforcer()
logger.info("RBAC enforcer ready.")

# 2.8: Celery — configure broker for webhook delivery (INFRA-03)
configure_celery(settings.redis_url)
logger.info("Celery configured for webhook delivery.")
```

Register new tools after existing tools:
```python
from hivemind.server.tools.publish_knowledge import publish_knowledge
from hivemind.server.tools.admin_tools import manage_roles

mcp.add_tool(Tool.from_function(publish_knowledge))
mcp.add_tool(Tool.from_function(manage_roles))
```

**Create `hivemind/server/tools/publish_knowledge.py`** (ACL-02):

```python
"""publish_knowledge MCP tool for HiveMind.

Allows an agent to explicitly publish knowledge from their private namespace
to the public commons, or unpublish it back to private. Publication is
reversible (ACL-02).

Security: Only the owning org can publish/unpublish their own items.
"""
```

`async def publish_knowledge(id: str, is_public: bool) -> dict | CallToolResult`:
- Extract auth from bearer token (same pattern as add_knowledge)
- Validate UUID format
- Fetch KnowledgeItem by id WHERE org_id == auth.org_id AND deleted_at IS NULL
- If not found, return 404 error (never reveal existence in other orgs)
- Update `item.is_public = is_public`
- Commit
- Return `{"id": str(item.id), "is_public": is_public, "message": "..."}`
- If `is_public=True`, message = "Knowledge published to the public commons."
- If `is_public=False`, message = "Knowledge unpublished from the public commons."

Docstring explains ACL-02 — publication is reversible.
  </action>
  <verify>
Run `python -c "from hivemind.server.tools.publish_knowledge import publish_knowledge; print('publish_knowledge importable')"` — should succeed.
Grep `hivemind/server/main.py` for "InjectionScanner" and "init_enforcer" and "publish_knowledge" to confirm all wired.
  </verify>
  <done>Server lifespan initializes injection scanner, rate limiter, RBAC enforcer, and Celery alongside Phase 1 components. publish_knowledge MCP tool allows reversible publication to the public commons. Both new tools are registered with the MCP server.</done>
</task>

<task type="auto">
  <name>Task 2: Create admin tools and wire webhook dispatch into approval flow</name>
  <files>hivemind/server/tools/admin_tools.py, hivemind/cli/client.py</files>
  <action>
**Create `hivemind/server/tools/admin_tools.py`** (ACL-03, ACL-04):

```python
"""manage_roles MCP tool for HiveMind.

Organization admins can manage agent roles and access policies within their
namespace. Supports three RBAC levels: namespace, category, and item (ACL-03).

Admin check: The calling agent must have the 'admin' role in their org's domain.
If not, the request is rejected (ACL-04).
"""
```

`async def manage_roles(action: str, agent_id: str, role: str | None = None, obj: str | None = None, permission: str | None = None) -> dict | CallToolResult`:
- Extract auth from bearer token
- Import `from hivemind.security.rbac import enforce, add_role_for_user, get_roles_for_user, add_policy, remove_policy`
- **Admin check**: Call `enforce(auth.agent_id, auth.org_id, f"namespace:{auth.org_id}", "*")`. If returns False, return error "Only organization admins can manage roles."
- Switch on `action`:
  - `"assign_role"`: requires `agent_id` and `role`. Call `add_role_for_user(agent_id, role, auth.org_id)`. Return `{"action": "assign_role", "agent_id": agent_id, "role": role, "domain": auth.org_id}`.
  - `"get_roles"`: requires `agent_id`. Call `get_roles_for_user(agent_id, auth.org_id)`. Return `{"action": "get_roles", "agent_id": agent_id, "roles": roles}`.
  - `"add_permission"`: requires `agent_id` (or `role`), `obj` (e.g. "category:bug_fix"), `permission` (e.g. "read", "write", "*"). Call `add_policy(agent_id or role, auth.org_id, obj, permission)`. Return confirmation.
  - `"remove_permission"`: same as add but calls `remove_policy()`.
  - Unknown action: return error with valid actions list.

`obj` format examples:
- `"namespace:<org_id>"` — org-wide access
- `"category:bug_fix"` — category-level access
- `"item:<uuid>"` — item-level access

**Update `hivemind/cli/client.py`** — Wire webhook dispatch into approve_contribution (INFRA-03):

Add import at top: `from hivemind.webhooks.tasks import dispatch_webhooks`

In `approve_contribution()`, after `session.commit()` and before `session.refresh(item)`, add:

```python
# INFRA-03: Dispatch webhook notifications for approved knowledge
try:
    dispatched = dispatch_webhooks(
        org_id=contribution.org_id,
        event="knowledge.approved",
        knowledge_item_id=str(item.id),
        category=final_category.value,
    )
    if dispatched > 0:
        import logging
        logging.getLogger(__name__).info(
            "Dispatched %d webhook(s) for knowledge item %s",
            dispatched, item.id,
        )
except Exception:
    # Webhook delivery is best-effort — don't block approval on delivery failure
    import logging
    logging.getLogger(__name__).warning(
        "Failed to dispatch webhooks for item %s — approval still succeeded",
        item.id,
        exc_info=True,
    )
```

The try/except ensures webhook failures never block the approval flow. Celery handles retries independently.
  </action>
  <verify>
Run `python -c "from hivemind.server.tools.admin_tools import manage_roles; print('manage_roles importable')"` — should succeed.
Grep `hivemind/cli/client.py` for "dispatch_webhooks" to confirm webhook integration.
  </verify>
  <done>manage_roles MCP tool provides org admin RBAC management (assign_role, get_roles, add_permission, remove_permission) with admin-only access check (ACL-03, ACL-04). approve_contribution triggers webhook dispatch on approval (INFRA-03). Webhook delivery is best-effort and never blocks the approval flow.</done>
</task>

</tasks>

<verification>
1. Server lifespan loads: PII pipeline, embedder, injection scanner, rate limiter, RBAC enforcer, Celery config
2. Six MCP tools registered: add_knowledge, search_knowledge, list_knowledge, delete_knowledge, publish_knowledge, manage_roles
3. publish_knowledge toggles is_public with org ownership check
4. manage_roles checks admin role before allowing policy changes
5. approve_contribution dispatches webhooks after successful approval
6. All files import without errors
</verification>

<success_criteria>
- Server initializes all Phase 2 security components at startup (no cold-start penalty)
- publish_knowledge provides reversible publication to public commons (ACL-02)
- manage_roles enables org admin to manage RBAC policies at namespace/category/item levels (ACL-03, ACL-04)
- Webhook dispatch fires after knowledge approval with retry via Celery (INFRA-03)
- API key auth is initialized alongside JWT (INFRA-04 infrastructure ready)
- Rate limiting is initialized with Redis (SEC-03 infrastructure ready)
</success_criteria>

<output>
After completion, create `.planning/phases/02-trust-security-hardening/02-06-SUMMARY.md`
</output>
