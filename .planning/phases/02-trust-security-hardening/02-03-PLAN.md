---
phase: 02-trust-security-hardening
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - hivemind/security/__init__.py
  - hivemind/security/rbac.py
  - hivemind/security/rbac_model.conf
  - hivemind/security/rate_limit.py
  - hivemind/security/api_key.py
autonomous: true
requirements: [ACL-03, ACL-04, SEC-03, INFRA-04]

must_haves:
  truths:
    - "get_enforcer() returns an AsyncEnforcer loaded with policy from PostgreSQL"
    - "enforce() checks (subject, domain, obj, action) against Casbin RBAC model"
    - "RBAC model supports three levels: namespace (domain), category (obj prefix), item (obj prefix)"
    - "Rate limiter provides tier-based limits (free/pro/enterprise) keyed by org_id:agent_id"
    - "API key helpers can create keys (returning raw key once), validate keys by hash lookup, and increment request counters"
  artifacts:
    - path: "hivemind/security/rbac.py"
      provides: "Casbin AsyncEnforcer singleton with PostgreSQL adapter"
      exports: ["get_enforcer", "enforce", "init_enforcer"]
    - path: "hivemind/security/rbac_model.conf"
      provides: "Casbin RBAC model with domain support"
      contains: "r = sub, dom, obj, act"
    - path: "hivemind/security/rate_limit.py"
      provides: "Rate limiting setup and tier-based dependency"
      exports: ["init_rate_limiter", "TIER_LIMITS", "check_burst"]
    - path: "hivemind/security/api_key.py"
      provides: "API key creation, validation, and request counting"
      exports: ["create_api_key", "validate_api_key", "increment_request_count"]
  key_links:
    - from: "hivemind/security/rbac.py"
      to: "casbin-async-sqlalchemy-adapter"
      via: "Adapter class for PostgreSQL policy storage"
      pattern: "casbin_async_sqlalchemy_adapter.Adapter"
    - from: "hivemind/security/rate_limit.py"
      to: "fastapi-limiter + Redis"
      via: "FastAPILimiter.init(redis)"
      pattern: "FastAPILimiter.init"
    - from: "hivemind/security/api_key.py"
      to: "hivemind/db/models.py"
      via: "ApiKey model for CRUD"
      pattern: "from hivemind.db.models import ApiKey"
---

<objective>
Build the security infrastructure modules: RBAC (Casbin), rate limiting (fastapi-limiter + Redis), and API key management. These are standalone modules wired into MCP tools in Plan 06.

Purpose: Create testable security primitives that can be composed into the request pipeline independently.
Output: New hivemind/security/ package with rbac.py, rate_limit.py, api_key.py, and rbac_model.conf
</objective>

<execution_context>
@/Users/amirkellousidhoum/.claude/get-shit-done/workflows/execute-plan.md
@/Users/amirkellousidhoum/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-trust-security-hardening/02-RESEARCH.md
@hivemind/server/auth.py
@hivemind/config.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Casbin RBAC module with domain-aware model</name>
  <files>hivemind/security/__init__.py, hivemind/security/rbac.py, hivemind/security/rbac_model.conf</files>
  <action>
Create the `hivemind/security/` directory and package.

**Create `hivemind/security/__init__.py`** — empty file (package marker).

**Create `hivemind/security/rbac_model.conf`** — Casbin model definition for domain-aware RBAC:
```ini
[request_definition]
r = sub, dom, obj, act

[policy_definition]
p = sub, dom, obj, act

[role_definition]
g = _, _, _

[policy_effect]
e = some(where (p.eft == allow))

[matchers]
m = g(r.sub, p.sub, r.dom) && r.dom == p.dom && r.obj == p.obj && r.act == p.act
```

Three enforcement levels are encoded via `obj` prefixes:
- Namespace: `obj = "namespace:<org_id>"` — org-wide access
- Category: `obj = "category:<knowledge_category>"` — category-level access
- Item: `obj = "item:<uuid>"` — individual item access

**Create `hivemind/security/rbac.py`** with:

Module-level `_enforcer: casbin.AsyncEnforcer | None = None` (lazy singleton, same pattern as PIIPipeline but async).

`async def init_enforcer() -> casbin.AsyncEnforcer`:
- Import `casbin` and `casbin_async_sqlalchemy_adapter`
- Get `settings.database_url` from hivemind.config (lazy import to avoid circular dep)
- Create adapter: `casbin_async_sqlalchemy_adapter.Adapter(database_url)` — the adapter needs a sync-style URL for SQLAlchemy, so replace `+asyncpg` with empty string if present (the adapter uses its own SQLAlchemy engine)
- Create enforcer: `casbin.AsyncEnforcer(model_path, adapter)` where `model_path` is resolved via `pathlib.Path(__file__).parent / "rbac_model.conf"`
- Call `await enforcer.load_policy()`
- Set `_enforcer = enforcer`
- Return enforcer

`async def get_enforcer() -> casbin.AsyncEnforcer`:
- If `_enforcer is None`, call `await init_enforcer()`
- Return `_enforcer`

`async def enforce(subject: str, domain: str, obj: str, action: str) -> bool`:
- Get enforcer via `get_enforcer()`
- Return `await enforcer.enforce(subject, domain, obj, action)`

`async def add_policy(subject: str, domain: str, obj: str, action: str) -> bool`:
- Get enforcer
- Return `await enforcer.add_policy(subject, domain, obj, action)`

`async def remove_policy(subject: str, domain: str, obj: str, action: str) -> bool`:
- Get enforcer
- Return `await enforcer.remove_policy(subject, domain, obj, action)`

`async def add_role_for_user(user: str, role: str, domain: str) -> bool`:
- Get enforcer
- Return `await enforcer.add_role_for_user_in_domain(user, role, domain)`

`async def get_roles_for_user(user: str, domain: str) -> list[str]`:
- Get enforcer
- Return `await enforcer.get_roles_for_user_in_domain(user, domain)`

`async def seed_default_policies(org_id: str) -> None`:
- Add default admin policy for the org: `p, admin, <org_id>, namespace:<org_id>, *`
- Add default contributor policies: `p, contributor, <org_id>, namespace:<org_id>, read` and `p, contributor, <org_id>, namespace:<org_id>, write`
- This is called when initializing RBAC for an existing org (per research Open Question 1 — default permissive)

Include docstrings on all functions referencing ACL-03 and ACL-04 requirement IDs.
  </action>
  <verify>
Run `python -c "from hivemind.security.rbac import get_enforcer, enforce, add_policy; print('RBAC module importable')"` — should succeed.
Run `python -c "import pathlib; p = pathlib.Path('hivemind/security/rbac_model.conf'); assert p.exists(); print('Model conf exists')"` — should succeed.
  </verify>
  <done>Casbin RBAC module exists with domain-aware model supporting namespace/category/item levels. AsyncEnforcer singleton loads policy from PostgreSQL via casbin-async-sqlalchemy-adapter. Policy CRUD helpers and default policy seeding are available.</done>
</task>

<task type="auto">
  <name>Task 2: Create rate limiting and API key management modules</name>
  <files>hivemind/security/rate_limit.py, hivemind/security/api_key.py</files>
  <action>
**Create `hivemind/security/rate_limit.py`** with:

`TIER_LIMITS` dict mapping tier names to per-minute contribution limits:
```python
TIER_LIMITS = {
    "free": {"contributions": 10, "searches": 30},
    "pro": {"contributions": 60, "searches": 200},
    "enterprise": {"contributions": 300, "searches": 1000},
}
```

`async def init_rate_limiter(redis_url: str) -> None`:
- Import `redis.asyncio as aioredis` and `FastAPILimiter` from `fastapi_limiter`
- Create Redis connection: `aioredis.from_url(redis_url, encoding="utf-8", decode_responses=True)`
- Call `await FastAPILimiter.init(redis_connection)`
- Store the redis connection in a module-level variable for anti-sybil use

`async def check_burst(org_id: str, contribution_id: str, redis_conn) -> bool`:
- Implements anti-sybil detection (SEC-03) using Redis ZSET
- Key: `"burst:{org_id}:contributions"`
- ZADD the contribution_id with score = current unix timestamp
- ZREMRANGEBYSCORE to remove entries older than `settings.burst_window_seconds`
- ZCARD to count entries in the window
- Return `True` if count > `settings.burst_threshold` (burst detected)
- Import settings lazily from `hivemind.config`

`def get_rate_limit_key(org_id: str, agent_id: str, operation: str) -> str`:
- Returns `f"{operation}:{org_id}:{agent_id}"` — namespaced rate limit key per Pitfall 6

**Create `hivemind/security/api_key.py`** with:

`import hashlib, secrets, uuid, datetime` from stdlib. Lazy import db models.

`def generate_api_key() -> tuple[str, str, str]`:
- Generate a random API key: `key = "hm_" + secrets.token_urlsafe(32)` (hm_ prefix for HiveMind)
- Compute prefix: `key_prefix = key[:8]`
- Compute hash: `key_hash = hashlib.sha256(key.encode()).hexdigest()`
- Return `(key, key_prefix, key_hash)` — the raw key is shown ONCE to the user

`async def create_api_key(org_id: str, agent_id: str, tier: str = "free") -> tuple[str, str]`:
- Generate key, prefix, hash using `generate_api_key()`
- Import `ApiKey` from `hivemind.db.models` and `get_session` from `hivemind.db.session`
- Insert new ApiKey record with all fields
- Return `(raw_key, str(api_key.id))` — raw key shown once, then discarded

`async def validate_api_key(raw_key: str) -> dict | None`:
- Compute hash of the raw key
- Look up ApiKey by key_hash
- If not found or not is_active, return None
- Check billing period: if `now - billing_period_start > billing_period_reset_days`, reset request_count to 0 and update billing_period_start
- Return dict with `org_id`, `agent_id`, `tier`, `request_count`, `api_key_id`

`async def increment_request_count(api_key_id: str) -> None`:
- Update request_count += 1 and last_used_at = now for the given API key ID

Include docstrings referencing INFRA-04 and SEC-03. Note that the raw API key is NEVER stored in the database (Pitfall: never store raw keys — research anti-pattern).
  </action>
  <verify>
Run `python -c "from hivemind.security.rate_limit import TIER_LIMITS, init_rate_limiter, check_burst; print(f'Tiers: {list(TIER_LIMITS.keys())}')"` — should print tiers.
Run `python -c "from hivemind.security.api_key import generate_api_key; key, prefix, hash = generate_api_key(); assert key.startswith('hm_'); assert len(prefix) == 8; assert len(hash) == 64; print(f'Key prefix: {prefix}')"` — should print key prefix.
  </verify>
  <done>Rate limiting module provides tier-based limits with anti-sybil burst detection via Redis ZSET. API key module generates hm_-prefixed keys, validates by hash lookup, manages billing period resets, and increments request counters. Raw keys are never stored.</done>
</task>

</tasks>

<verification>
1. `hivemind/security/` package exists with __init__.py
2. rbac_model.conf contains domain-aware RBAC model definition
3. RBAC module imports cleanly and provides enforce(), add_policy(), seed_default_policies()
4. Rate limit module provides TIER_LIMITS and burst detection
5. API key module generates, validates, and counts keys
6. `pip install pycasbin casbin-async-sqlalchemy-adapter fastapi-limiter` succeeds (verify packages installable)
</verification>

<success_criteria>
- Casbin RBAC enforcer is configurable at namespace, category, and item levels
- Rate limiting provides tier-based limits keyed by org_id:agent_id
- Anti-sybil detection flags burst contribution patterns via Redis ZSET
- API key CRUD supports create (returns raw key once), validate (hash lookup), and increment
- All modules are standalone and testable before integration in Plan 06
</success_criteria>

<output>
After completion, create `.planning/phases/02-trust-security-hardening/02-03-SUMMARY.md`
</output>
