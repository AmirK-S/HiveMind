"""SQLAlchemy ORM models for HiveMind.

Tables:
- pending_contributions  — inbound knowledge queued for user approval (PII-stripped)
- knowledge_items        — approved knowledge in the commons (with vector embeddings)
- quality_signals        — per-item behavioral signals for quality scoring (QI-01, QI-02)
- deployment_config      — key/value store for deployment metadata (e.g. pinned model revision)

Design decisions:
- All tables carry org_id for namespace isolation (ACL-01)
- Knowledge provenance fields (source_agent_id, contributed_at, content_hash, etc.)
  are set on INSERT and never updated — immutable per KM-01
- content_hash is SHA-256 of the stripped content
- Unique constraint on (content_hash, org_id) prevents intra-org duplicates while
  allowing two orgs to contribute identical knowledge (pitfall 4 from research)
- embedding column uses VECTOR(384) matching all-MiniLM-L6-v2 output dimensions
- HNSW index created at table creation time (before any data) to avoid table-lock
  during a future online re-index
- quality_score defaults to 0.5 (neutral prior for new items, QI-01)
- Bi-temporal columns use four explicit nullable DateTime(tz) columns (KM-05):
    contributed_at = system-time start (existing, immutable)
    expired_at     = system-time end (NULL = current version)
    valid_at       = world-time start (NULL = "valid since approval")
    invalid_at     = world-time end (NULL = "still valid")
  TSTZRANGE avoided — SQLAlchemy has known DataError friction with DateTimeTZRange
"""

import datetime
import enum
import uuid

from pgvector.sqlalchemy import VECTOR
from sqlalchemy import (
    Boolean,
    DateTime,
    Enum,
    Float,
    ForeignKey,
    Index,
    Integer,
    String,
    Text,
    UniqueConstraint,
)
from sqlalchemy.dialects.postgresql import JSONB, UUID
from sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column


class KnowledgeCategory(str, enum.Enum):
    """Controlled vocabulary for classifying knowledge items (KM-04)."""

    bug_fix = "bug_fix"
    config = "config"
    domain_expertise = "domain_expertise"
    workaround = "workaround"
    pricing_data = "pricing_data"
    regulatory_rule = "regulatory_rule"
    tooling = "tooling"
    reasoning_trace = "reasoning_trace"
    failed_approach = "failed_approach"
    version_workaround = "version_workaround"
    general = "general"


class Base(DeclarativeBase):
    """Shared declarative base for all ORM models."""

    pass


class PendingContribution(Base):
    """Inbound knowledge waiting for user approval.

    Content is PII-stripped before being written here (TRUST-01).  The record
    is created by the add_knowledge MCP tool and consumed by the CLI review
    command.  On approval it becomes a KnowledgeItem; on rejection it is
    deleted.
    """

    __tablename__ = "pending_contributions"

    id: Mapped[uuid.UUID] = mapped_column(
        UUID(as_uuid=True), primary_key=True, default=uuid.uuid4
    )

    # Namespace isolation (ACL-01)
    org_id: Mapped[str] = mapped_column(String(255), nullable=False, index=True)

    # Immutable provenance (KM-01)
    source_agent_id: Mapped[str] = mapped_column(String(255), nullable=False)
    run_id: Mapped[str | None] = mapped_column(String(255), nullable=True)
    content: Mapped[str] = mapped_column(Text, nullable=False)  # already PII-stripped
    content_hash: Mapped[str] = mapped_column(
        String(64), nullable=False
    )  # SHA-256 of stripped content

    # Knowledge classification (KM-04)
    category: Mapped[KnowledgeCategory] = mapped_column(
        Enum(KnowledgeCategory, name="knowledgecategory"), nullable=False
    )

    # Quality signals
    confidence: Mapped[float] = mapped_column(Float, default=0.8, nullable=False)

    # Framework/language metadata (KM-04)
    framework: Mapped[str | None] = mapped_column(String(100), nullable=True)
    language: Mapped[str | None] = mapped_column(String(50), nullable=True)
    version: Mapped[str | None] = mapped_column(String(50), nullable=True)
    tags: Mapped[dict | None] = mapped_column(JSONB, nullable=True)

    # Timestamps
    contributed_at: Mapped[datetime.datetime] = mapped_column(
        DateTime(timezone=True),
        nullable=False,
        default=datetime.datetime.utcnow,
    )

    # Safety
    is_sensitive_flagged: Mapped[bool] = mapped_column(
        Boolean, default=False, nullable=False
    )


class KnowledgeItem(Base):
    """Approved knowledge in the commons.

    Created from PendingContribution on user approval.  Provenance fields
    (source_agent_id, contributed_at, org_id, category, content_hash) are
    copied from the pending record and are immutable (KM-01).

    The embedding column holds a 384-dimensional vector generated by
    all-MiniLM-L6-v2 (KM-08).  The HNSW index enables approximate nearest-
    neighbour cosine search without a full table scan.
    """

    __tablename__ = "knowledge_items"

    id: Mapped[uuid.UUID] = mapped_column(
        UUID(as_uuid=True), primary_key=True, default=uuid.uuid4
    )

    # Namespace isolation (ACL-01)
    org_id: Mapped[str] = mapped_column(String(255), nullable=False, index=True)
    is_public: Mapped[bool] = mapped_column(
        Boolean, default=False, nullable=False
    )  # False = private namespace only

    # Immutable provenance (KM-01)
    source_agent_id: Mapped[str] = mapped_column(String(255), nullable=False)
    run_id: Mapped[str | None] = mapped_column(String(255), nullable=True)
    content: Mapped[str] = mapped_column(Text, nullable=False)
    content_hash: Mapped[str] = mapped_column(String(64), nullable=False)

    # Knowledge classification (KM-04)
    category: Mapped[KnowledgeCategory] = mapped_column(
        Enum(KnowledgeCategory, name="knowledgecategory"), nullable=False
    )

    # Quality signals
    confidence: Mapped[float] = mapped_column(Float, default=0.8, nullable=False)

    # Framework/language metadata (KM-04)
    framework: Mapped[str | None] = mapped_column(String(100), nullable=True)
    language: Mapped[str | None] = mapped_column(String(50), nullable=True)
    version: Mapped[str | None] = mapped_column(String(50), nullable=True)
    tags: Mapped[dict | None] = mapped_column(JSONB, nullable=True)

    # Vector embedding (KM-08 — 384 dims for all-MiniLM-L6-v2)
    embedding: Mapped[list | None] = mapped_column(VECTOR(384), nullable=True)

    # Timestamps — contributed_at is immutable provenance copied from pending
    contributed_at: Mapped[datetime.datetime] = mapped_column(
        DateTime(timezone=True), nullable=False
    )
    approved_at: Mapped[datetime.datetime] = mapped_column(
        DateTime(timezone=True),
        nullable=False,
        default=datetime.datetime.utcnow,
    )
    # Soft-delete timestamp — set by delete_knowledge tool; NULL means active
    deleted_at: Mapped[datetime.datetime | None] = mapped_column(
        DateTime(timezone=True), nullable=True, default=None
    )

    # Quality scoring (QI-01, QI-02) — updated via behavioral signal aggregation
    quality_score: Mapped[float] = mapped_column(
        Float, nullable=False, server_default="0.5"
    )
    retrieval_count: Mapped[int] = mapped_column(
        Integer, nullable=False, server_default="0"
    )
    helpful_count: Mapped[int] = mapped_column(
        Integer, nullable=False, server_default="0"
    )
    not_helpful_count: Mapped[int] = mapped_column(
        Integer, nullable=False, server_default="0"
    )

    # Bi-temporal columns (KM-05)
    # system-time start = contributed_at (existing, immutable)
    # system-time end   = expired_at (NULL = current version)
    # world-time start  = valid_at   (NULL = "valid since approval")
    # world-time end    = invalid_at (NULL = "still valid")
    valid_at: Mapped[datetime.datetime | None] = mapped_column(
        DateTime(timezone=True), nullable=True
    )
    invalid_at: Mapped[datetime.datetime | None] = mapped_column(
        DateTime(timezone=True), nullable=True
    )
    expired_at: Mapped[datetime.datetime | None] = mapped_column(
        DateTime(timezone=True), nullable=True
    )

    __table_args__ = (
        # Prevents intra-org duplicates; allows same content across orgs (pitfall 4)
        UniqueConstraint("content_hash", "org_id", name="uq_knowledge_items_hash_org"),
        # HNSW index for cosine similarity search (created before data to avoid lock)
        Index(
            "ix_knowledge_items_embedding_hnsw",
            "embedding",
            postgresql_using="hnsw",
            postgresql_with={"m": 16, "ef_construction": 64},
            postgresql_ops={"embedding": "vector_cosine_ops"},
        ),
        # Composite index for the common search filter pattern
        Index(
            "ix_knowledge_items_org_public",
            "org_id",
            "is_public",
        ),
    )


class QualitySignal(Base):
    """Behavioral signal recorded for a knowledge item (QI-01, QI-02).

    Each row represents one observable event (retrieval, outcome report,
    contradiction flag) associated with a knowledge item.  The scorer module
    aggregates these signals to compute quality_score.

    signal_type vocabulary:
    - "retrieval"           : item was returned in a search result
    - "outcome_solved"      : agent reported the item solved their problem
    - "outcome_not_helpful" : agent reported the item was not helpful
    - "contradiction"       : item conflicts with another approved item

    run_id enables deduplication — the same agent run should not count twice
    for the same outcome signal type on the same item.
    """

    __tablename__ = "quality_signals"

    id: Mapped[uuid.UUID] = mapped_column(
        UUID(as_uuid=True), primary_key=True, default=uuid.uuid4
    )

    knowledge_item_id: Mapped[uuid.UUID] = mapped_column(
        UUID(as_uuid=True),
        ForeignKey("knowledge_items.id", ondelete="CASCADE"),
        nullable=False,
    )

    signal_type: Mapped[str] = mapped_column(String(50), nullable=False)
    agent_id: Mapped[str | None] = mapped_column(String(255), nullable=True)
    run_id: Mapped[str | None] = mapped_column(String(255), nullable=True)
    # Named signal_metadata to avoid collision with SQLAlchemy's reserved 'metadata' attr
    signal_metadata: Mapped[dict | None] = mapped_column(
        "metadata", JSONB, nullable=True
    )

    created_at: Mapped[datetime.datetime] = mapped_column(
        DateTime(timezone=True),
        nullable=False,
        default=datetime.datetime.utcnow,
    )

    __table_args__ = (
        # Index on knowledge_item_id for aggregation queries
        Index("ix_quality_signals_knowledge_item_id", "knowledge_item_id"),
        # Composite index on (knowledge_item_id, signal_type) for filtered aggregation
        Index("ix_quality_signals_item_type", "knowledge_item_id", "signal_type"),
    )


class DeploymentConfig(Base):
    """Key/value store for deployment-time configuration.

    Used primarily to pin the embedding model name and HuggingFace revision
    hash at first startup (KM-08).  This allows future migrations to detect
    model version changes and trigger re-embedding if needed.

    Example keys:
    - embedding_model_name    → "sentence-transformers/all-MiniLM-L6-v2"
    - embedding_model_revision → "<git-commit-hash>"
    - schema_version           → "1"
    """

    __tablename__ = "deployment_config"

    key: Mapped[str] = mapped_column(String(255), primary_key=True)
    value: Mapped[str] = mapped_column(Text, nullable=False)
    created_at: Mapped[datetime.datetime] = mapped_column(
        DateTime(timezone=True),
        nullable=False,
        default=datetime.datetime.utcnow,
    )
    updated_at: Mapped[datetime.datetime] = mapped_column(
        DateTime(timezone=True),
        nullable=False,
        default=datetime.datetime.utcnow,
        onupdate=datetime.datetime.utcnow,
    )


class ApiKey(Base):
    """API key for agent/integration authentication with tier-based rate limits (INFRA-04).

    The raw key is never stored — only a SHA-256 hash is persisted.  The first
    8 characters are stored as key_prefix for safe display and lookup.

    Tiers: "free" (default), "pro", "enterprise" — drive rate-limit thresholds.
    """

    __tablename__ = "api_keys"

    id: Mapped[uuid.UUID] = mapped_column(
        UUID(as_uuid=True), primary_key=True, default=uuid.uuid4
    )

    # Safe display — first 8 chars of the raw key (e.g. "hm_12345")
    key_prefix: Mapped[str] = mapped_column(String(8), nullable=False)

    # SHA-256 of the full API key — unique; raw key is never stored
    key_hash: Mapped[str] = mapped_column(String(64), nullable=False, unique=True)

    # Namespace isolation (ACL-01)
    org_id: Mapped[str] = mapped_column(String(255), nullable=False)
    agent_id: Mapped[str] = mapped_column(String(255), nullable=False)

    # Tier determines rate-limit thresholds (SEC-03)
    tier: Mapped[str] = mapped_column(String(20), nullable=False, default="free")

    # Usage tracking for billing-period quota enforcement
    request_count: Mapped[int] = mapped_column(Integer, nullable=False, default=0)
    billing_period_start: Mapped[datetime.datetime] = mapped_column(
        DateTime(timezone=True),
        nullable=False,
        default=datetime.datetime.utcnow,
    )
    billing_period_reset_days: Mapped[int] = mapped_column(
        Integer, nullable=False, default=30
    )

    is_active: Mapped[bool] = mapped_column(Boolean, nullable=False, default=True)

    # Timestamps
    created_at: Mapped[datetime.datetime] = mapped_column(
        DateTime(timezone=True),
        nullable=False,
        default=datetime.datetime.utcnow,
    )
    last_used_at: Mapped[datetime.datetime | None] = mapped_column(
        DateTime(timezone=True), nullable=True
    )

    __table_args__ = (
        # Explicit index on key_hash for O(1) key verification lookups
        Index("ix_api_keys_key_hash", "key_hash"),
        # Index on org_id for per-org key listing
        Index("ix_api_keys_org_id", "org_id"),
    )


class AutoApproveRule(Base):
    """Per-org, per-category auto-approval configuration (TRUST-04).

    When is_auto_approve is True for a given (org_id, category) pair, the
    approval pipeline skips the human review step for contributions in that
    category.  Each org can set different rules per category, but only one
    rule per (org, category) pair is allowed (unique constraint).
    """

    __tablename__ = "auto_approve_rules"

    id: Mapped[uuid.UUID] = mapped_column(
        UUID(as_uuid=True), primary_key=True, default=uuid.uuid4
    )

    org_id: Mapped[str] = mapped_column(String(255), nullable=False)

    # Reuse the existing knowledgecategory enum type — do not create a new one
    category: Mapped[KnowledgeCategory] = mapped_column(
        Enum(KnowledgeCategory, name="knowledgecategory"), nullable=False
    )

    is_auto_approve: Mapped[bool] = mapped_column(
        Boolean, nullable=False, default=False
    )

    # Timestamps
    created_at: Mapped[datetime.datetime] = mapped_column(
        DateTime(timezone=True),
        nullable=False,
        default=datetime.datetime.utcnow,
    )
    updated_at: Mapped[datetime.datetime] = mapped_column(
        DateTime(timezone=True),
        nullable=False,
        default=datetime.datetime.utcnow,
        onupdate=datetime.datetime.utcnow,
    )

    __table_args__ = (
        # One rule per (org, category) pair — prevents contradictory entries
        UniqueConstraint(
            "org_id", "category", name="uq_auto_approve_rules_org_category"
        ),
    )


class WebhookEndpoint(Base):
    """Registered webhook endpoint for near-real-time push delivery (INFRA-03).

    When knowledge is approved or published the delivery worker POSTs a JSON
    payload to each active endpoint subscribed to the relevant event type.

    event_types is a JSON array of strings, e.g.:
        ["knowledge.approved", "knowledge.published"]
    NULL means "subscribe to all events".
    """

    __tablename__ = "webhook_endpoints"

    id: Mapped[uuid.UUID] = mapped_column(
        UUID(as_uuid=True), primary_key=True, default=uuid.uuid4
    )

    org_id: Mapped[str] = mapped_column(String(255), nullable=False, index=True)
    url: Mapped[str] = mapped_column(Text, nullable=False)

    # JSON array of event type strings; NULL = subscribe to all events
    event_types: Mapped[dict | None] = mapped_column(JSONB, nullable=True)

    is_active: Mapped[bool] = mapped_column(Boolean, nullable=False, default=True)

    # Timestamps
    created_at: Mapped[datetime.datetime] = mapped_column(
        DateTime(timezone=True),
        nullable=False,
        default=datetime.datetime.utcnow,
    )
    updated_at: Mapped[datetime.datetime] = mapped_column(
        DateTime(timezone=True),
        nullable=False,
        default=datetime.datetime.utcnow,
        onupdate=datetime.datetime.utcnow,
    )
